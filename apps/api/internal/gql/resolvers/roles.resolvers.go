package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/samber/lo"
	"github.com/satont/stream/apps/api/internal/gql/gqlmodel"
	"github.com/satont/stream/apps/api/internal/repositories/role"
)

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input gqlmodel.CreateRoleInput) (*gqlmodel.Role, error) {
	userID, err := r.sessionStorage.GetUserID(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get user id from session: %w", err)
	}

	var features []string
	for _, feature := range input.Features {
		features = append(features, feature.String())
	}

	role, err := r.rolesRepo.Create(
		ctx,
		role.CreateOpts{
			ChannelID: uuid.MustParse(userID),
			Name:      input.Name,
			ImageUrl:  input.ImageURL.Value(),
			Features:  features,
		},
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create role: %w", err)
	}

	return lo.ToPtr(r.mapper.DbRoleToGql(*role)), nil
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, id uuid.UUID, input gqlmodel.UpdateRoleInput) (*gqlmodel.Role, error) {
	var features []string
	if input.Features.Value() != nil {
		for _, feature := range input.Features.Value() {
			features = append(features, feature.String())
		}
	}

	role, err := r.rolesRepo.UpdateByID(
		ctx,
		id,
		role.UpdateOpts{
			Name:     input.Name.Value(),
			ImageUrl: input.ImageURL.Value(),
			Features: &features,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update role: %w", err)
	}

	return lo.ToPtr(r.mapper.DbRoleToGql(*role)), nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.rolesRepo.DeleteByID(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete role: %w", err)
	}

	return true, nil
}

// UserAssigneRole is the resolver for the userAssigneRole field.
func (r *mutationResolver) UserAssigneRole(ctx context.Context, userID uuid.UUID, roleID uuid.UUID) (bool, error) {
	requestedUserID, err := r.sessionStorage.GetUserID(ctx)
	if err != nil {
		return false, err
	}

	role, err := r.rolesRepo.FindOneByID(ctx, roleID)
	if err != nil {
		return false, fmt.Errorf("failed to fetch role: %w", err)
	}

	if role.ChannelID != uuid.MustParse(requestedUserID) {
		return false, fmt.Errorf("role does not belong to the user's channel")
	}

	if err := r.rolesRepo.AssignRoleToUser(ctx, roleID, userID); err != nil {
		return false, fmt.Errorf("failed to assign role to user: %w", err)
	}

	return true, nil
}

// UserUnassignRole is the resolver for the userUnassignRole field.
func (r *mutationResolver) UserUnassignRole(ctx context.Context, userID uuid.UUID, roleID uuid.UUID) (bool, error) {
	requestedUserID, err := r.sessionStorage.GetUserID(ctx)
	if err != nil {
		return false, err
	}

	role, err := r.rolesRepo.FindOneByID(ctx, roleID)
	if err != nil {
		return false, fmt.Errorf("failed to fetch role: %w", err)
	}

	if role.ChannelID != uuid.MustParse(requestedUserID) {
		return false, fmt.Errorf("role does not belong to the user's channel")
	}

	if err := r.rolesRepo.UnassignRoleFromUser(ctx, roleID, userID); err != nil {
		return false, fmt.Errorf("failed to unassign role from user: %w", err)
	}

	return true, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]gqlmodel.Role, error) {
	userID, err := r.sessionStorage.GetUserID(ctx)
	if err != nil {
		return nil, err
	}

	roles, err := r.rolesRepo.FindManyByChannelID(ctx, uuid.MustParse(userID))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch roles: %w", err)
	}

	gqlRoles := make([]gqlmodel.Role, 0, len(roles))
	for _, role := range roles {
		gqlRoles = append(gqlRoles, r.mapper.DbRoleToGql(role))
	}

	return gqlRoles, nil
}
